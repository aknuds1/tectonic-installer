module "bootkube" {
  source = "../../modules/bootkube"

  cloud_provider = ""
  cluster_name = "{{ cluster_name }}"
  kube_apiserver_url = "https://{{ cluster_domain }}:443"
  oidc_issuer_url = "https://{{ console_domain }}:443/identity"
  container_images = {{ container_images }}
  versions = {{ versions }}
  service_cidr = "{{ service_cidr }}"
  cluster_cidr = "{{ cluster_cidr }}"
  advertise_address = "0.0.0.0"
  anonymous_auth = "false"
  oidc_username_claim = "email"
  oidc_groups_claim = "groups"
  oidc_client_id = "tectonic-kubectl"
  etcd_endpoints = {{ etcd_dns_names }}
  etcd_tls_enabled = true
  master_count = 1
  etcd_ca_cert = "/dev/null"
  etcd_client_cert = "/dev/null"
  etcd_client_key = "/dev/null"
  ca_key = ""
  ca_cert = ""
  ca_key_alg = "RSA"
  etcd_cert_dns_names = {{ etcd_dns_names }}
}

module "tectonic" {
  source = "../../modules/tectonic"

  platform = "digitalocean"
  cluster_name = "{{ cluster_name }}"
  base_address = "{{ console_domain }}"
  kube_apiserver_url = "https://{{ cluster_domain }}:443"
  container_images = {{ container_images }}
  versions = {{ versions }}
  license_path = "{{ tectonic_license_path }}"
  pull_secret_path = "{{ pull_secret_path }}"
  admin_email = "{{ admin_email }}"
  admin_password_hash = "{{ admin_password_hash }}"
  update_channel = "{{ update_channel }}"
  update_app_id = "{{ update_app_id }}"
  update_server = "{{ update_server }}"
  ca_generated = "${module.bootkube.ca_cert == "" ? false : true}"
  ca_cert = "${module.bootkube.ca_cert}"
  ca_key_alg = "${module.bootkube.ca_key_alg}"
  ca_key = "${module.bootkube.ca_key}"
  console_client_id = "tectonic-console"
  kubectl_client_id = "tectonic-kubectl"
  ingress_kind = "NodePort"
  experimental = false
  master_count = 1
  stats_url = "{{ stats_url }}"
  image_re = "{{ image_re }}"
}

module "flannel-vxlan" {
  source = "../../modules/net/flannel-vxlan"

  flannel_image = "{{ flannel_image }}"
  flannel_cni_image = "{{ flannel_cni_image }}"
  cluster_cidr = "{{ cluster_cidr }}"
  bootkube_id = "${module.bootkube.id}"
}

data "archive_file" "assets" {
  type = "zip"
  source_dir = "./generated/"
  # Because the archive_file provider is a data source, depends_on can't be
  # used to guarantee that the tectonic/bootkube modules have generated
  # all the assets on disk before trying to archive them. Instead, we use their
  # ID outputs, that are only computed once the assets have actually been
  # written to disk. We re-hash the IDs (or dedicated module outputs, like module.bootkube.content_hash)
  # to make the filename shorter, since there is no security nor collision risk anyways.
  #
  # Additionally, data sources do not support managing any lifecycle whatsoever,
  # and therefore, the archive is never deleted. To avoid cluttering the module
  # folder, we write it in the Terraform managed hidden folder `.terraform`.
  output_path = "./.terraform/generated_${sha1("${module.tectonic.id} ${module.bootkube.id} ${module.flannel-vxlan.id}")}.zip"
}

# Copy kubeconfig to master nodes
resource "null_resource" "master_nodes" {
  count = 1
  # Re-provision on changes to masters
  triggers {
    master_address = "${element(digitalocean_droplet.master_node.*.ipv4_address, count.index)}",
  }

  connection {
    type = "ssh"
    host = "${element(digitalocean_droplet.master_node.*.ipv4_address, count.index)}"
    user = "core"
    private_key = "${file("{{ do_ssh_key_path }}")}"
    timeout = "1m"
  }

  provisioner "file" {
    content = "${module.bootkube.kubeconfig}"
    destination = "$HOME/kubeconfig"
  }

  provisioner "remote-exec" {
    inline = [
      "sudo mv $HOME/kubeconfig /etc/kubernetes/",
    ]
  }
}

# Copy assets to first master node
resource "null_resource" "first_master" {
  # Re-provision on changes to first master node
  triggers {
    node_address = "${digitalocean_droplet.master_node.*.ipv4_address[0]}"
  }

  connection {
    type = "ssh"
    host = "${digitalocean_droplet.master_node.*.ipv4_address[0]}"
    user = "core"
    private_key = "${file("{{ do_ssh_key_path }}")}"
    timeout = "1m"
  }

  provisioner "file" {
    source = "${data.archive_file.assets.output_path}"
    destination = "$HOME/tectonic.zip"
  }

  provisioner "file" {
    source = "${path.root}/resources/bootstrap-first-master.sh"
    destination = "$HOME/bootstrap-first-master.sh"
  }

  provisioner "remote-exec" {
    inline = [
      "chmod +x $HOME/bootstrap-first-master.sh",
      "$HOME/bootstrap-first-master.sh{% if not disable_tectonic %} --enable-tectonic{% endif %}",
      "rm $HOME/bootstrap-first-master.sh",
    ]
  }
}

{#
# Copy kubeconfig to worker nodes
resource "null_resource" "worker_nodes" {
  count = "${var.tectonic_worker_count}"
  # Re-provision on changes to workers
  triggers {
    node_address = "${element(module.workers.node_addresses, count.index)}",
  }

  connection {
    type = "ssh"
    host = "${element(module.workers.node_addresses, count.index)}"
    user = "core"
    private_key = "${file("${var.tectonic_do_ssh_key_path}")}"
    timeout = "1m"
  }

  provisioner "file" {
    content = "${module.bootkube.kubeconfig}"
    destination = "$HOME/kubeconfig"
  }

  provisioner "remote-exec" {
    inline = [
      "sudo mv $HOME/kubeconfig /etc/kubernetes/",
    ]
  }
}
#}
