resource "digitalocean_droplet" "etcd_node" {
  count = "{{ etcd_count }}"
  name = "{{ cluster_name }}-etcd-${count.index}"
  image = "{{ droplet_image }}"
  region = "{{ region }}"
  size = "{{ etcd_size }}"
  ssh_keys = [{{ ssh_keys }}]
  tags = {{ extra_tags }}
  user_data = "${data.ignition_config.etcd.*.rendered[count.index]}"
}

# Create separate domain for etcd nodes, because depending on main cluster domain would cause
# a dependency cycle, as the latter must be instantiated with the API server IP address
resource "digitalocean_domain" "etcd" {
  name = "etcd.{{ cluster_domain }}"
  ip_address = "${digitalocean_droplet.etcd_node.*.ipv4_address[0]}"
}

resource "digitalocean_record" "etcd_nodes" {
  count = "{{ etcd_count }}"
  domain = "${digitalocean_domain.etcd.id}"
  type = "A"
  name = "etcd-${count.index}"
  value = "${digitalocean_droplet.etcd_node.*.ipv4_address[count.index]}"
}

data "ignition_config" "etcd" {
  count = "{{ etcd_count }}"

  systemd = [
    "${data.ignition_systemd_unit.locksmithd.*.id[count.index]}",
    "${data.ignition_systemd_unit.etcd3.*.id[count.index]}",
    "${data.ignition_systemd_unit.etcd_unzip_tls.id}",
    "${data.ignition_systemd_unit.swap.id}",
    "${data.ignition_systemd_unit.sshguard.id}",
  ]

  files = [
    "${data.ignition_file.node_hostname.*.id[count.index]}",
    "${data.ignition_file.etcd_tls_zip.id}",
  ]
}

data "ignition_file" "node_hostname" {
  count = "{{ etcd_count }}"
  path = "/etc/hostname"
  mode = 0644
  filesystem = "root"

  content {
    content = "etcd-${count.index}.etcd.{{ cluster_domain }}"
  }
}

data "ignition_file" "etcd_tls_zip" {
  path = "/etc/ssl/etcd/tls.zip"
  mode = 0400
  uid = 0
  gid = 0
  filesystem = "root"

  content {
    mime = "application/octet-stream"
    content = "${module.bootkube.etcd_tls_zip}"
  }
}

data "ignition_systemd_unit" "etcd_unzip_tls" {
  name = "etcd-unzip-tls.service"
  enable = true

  content = <<EOF
ConditionPathExists=!/etc/ssl/etcd/ca.crt
[Service]
Type=oneshot
WorkingDirectory=/etc/ssl/etcd
ExecStart=/usr/bin/bash -c 'unzip /etc/ssl/etcd/tls.zip && \
chown etcd:etcd /etc/ssl/etcd/peer.* && \
chown etcd:etcd /etc/ssl/etcd/client.* && \
chown etcd:etcd /etc/ssl/etcd/server.* && \
chmod 0400 /etc/ssl/etcd/peer.* /etc/ssl/etcd/server.* /etc/ssl/etcd/client.*'
[Install]
WantedBy=multi-user.target
RequiredBy=etcd-member.service locksmithd.service
EOF
}

data "ignition_systemd_unit" "locksmithd" {
  count = "{{ etcd_count }}"
  name = "locksmithd.service"
  enable = true
  dropin = [
    {
      name = "40-etcd-lock.conf"
      content = <<EOF
[Service]
Environment=REBOOT_STRATEGY=etcd-lock
Environment="LOCKSMITHD_ETCD_CAFILE=/etc/ssl/etcd/ca.crt"
Environment="LOCKSMITHD_ETCD_KEYFILE=/etc/ssl/etcd/client.key"
Environment="LOCKSMITHD_ETCD_CERTFILE=/etc/ssl/etcd/client.crt"
Environment="LOCKSMITHD_ENDPOINT=https://etcd-${count.index}.etcd.{{ cluster_domain }}:2379"
EOF
    },
  ]
}

data "ignition_systemd_unit" "etcd3" {
  count = {{ etcd_count }}
  name = "etcd-member.service"
  enable = true
  dropin = [
    {
      name = "40-etcd-cluster.conf"
      content = <<EOF
[Service]
Environment="ETCD_IMAGE={{ container_image }}"
Environment="RKT_RUN_ARGS=--volume etcd-ssl,kind=host,source=/etc/ssl/etcd \
  --mount volume=etcd-ssl,target=/etc/ssl/etcd"
ExecStart=
ExecStart=/usr/lib/coreos/etcd-wrapper \
  --name={{ cluster_name }}-etcd-${count.index} \
  --advertise-client-urls=https://etcd-${count.index}.etcd.{{ cluster_domain }}:2379 \
  --cert-file=/etc/ssl/etcd/server.crt --key-file=/etc/ssl/etcd/server.key --peer-cert-file=/etc/ssl/etcd/peer.crt \ --peer-key-file=/etc/ssl/etcd/peer.key --peer-trusted-ca-file=/etc/ssl/etcd/ca.crt --peer-client-cert-auth=true" \
  --initial-advertise-peer-urls=https://etcd-${count.index}.etcd.{{ cluster_domain }}:2380 \
  --listen-client-urls=https://0.0.0.0:2379 \
  --listen-peer-urls=https://0.0.0.0:2380 \
  --initial-cluster="{{ initial_etcd_cluster_str }}"
EOF
    },
  ]
}

data "ignition_systemd_unit" "swap" {
  name = "swap.service"
  enable = {{ enable_swap }}
  content = <<EOF
[Unit]
Description=Turn on swap

[Service]
Type=oneshot
ExecStartPre=-/usr/bin/rm -rf /var/vm
ExecStartPre=/usr/bin/mkdir -p /var/vm
ExecStartPre=/usr/bin/touch /var/vm/swapfile1
ExecStartPre=/bin/bash -c "fallocate -l {{ swap_size }} /var/vm/swapfile1"
ExecStartPre=/usr/bin/chmod 600 /var/vm/swapfile1
ExecStartPre=/usr/sbin/mkswap /var/vm/swapfile1
ExecStartPre=/usr/sbin/sysctl vm.swappiness=10
ExecStart=/sbin/swapon /var/vm/swapfile1
ExecStop=/sbin/swapoff /var/vm/swapfile1
ExecStopPost=-/usr/bin/rm -rf /var/vm
RemainAfterExit=true

[Install]
WantedBy=multi-user.target
EOF
}

data "ignition_systemd_unit" "sshguard" {
  name = "sshguard.service"
  enable = true
  content = <<EOF
[Unit]
Description=%p
After=network-online.target

[Service]
TimeoutStartSec=0
Restart=always
RestartSec=5s

# Set up sshguard tables
ExecStartPre=-/usr/sbin/iptables -N sshguard
ExecStartPre=-/usr/sbin/ip6tables -N sshguard

# Link sshguard tables to main INPUT tables
ExecStartPre=-/usr/sbin/iptables -D INPUT -j sshguard
ExecStartPre=-/usr/sbin/ip6tables -D INPUT -j sshguard
ExecStartPre=-/usr/sbin/iptables -A INPUT -j sshguard
ExecStartPre=-/usr/sbin/ip6tables -A INPUT -j sshguard

ExecStart=/bin/sh -c 'journalctl -afb -p info -n1 -o cat -t sshd | \
   rkt run \
      --insecure-options=image \
      --interactive \
      --net=host \
      --stage1-name=coreos.com/rkt/stage1-fly:1.21.0 docker://mischief/sshguard \
      --caps-retain=CAP_NET_ADMIN'

[Install]
WantedBy=multi-user.target

[X-Fleet]
Global=true
EOF
}
